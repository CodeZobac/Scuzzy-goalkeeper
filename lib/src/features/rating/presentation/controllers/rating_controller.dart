import 'package:flutter/material.dart';
import '../../data/models/rating.dart';
import '../../data/repositories/rating_repository.dart';
import '../../../booking/data/models/booking.dart';

class RatingController extends ChangeNotifier {
  final RatingRepository _repository;

  RatingController(this._repository);

  // State variables
  bool _isLoading = false;
  String? _error;
  double _reflexes = 50;
  double _positioning = 50;
  double _distribution = 50;
  double _communication = 50;
  String _comment = '';
  bool _hasSubmitted = false;

  // Getters
  bool get isLoading => _isLoading;
  String? get error => _error;
  double get reflexes => _reflexes;
  double get positioning => _positioning;
  double get distribution => _distribution;
  double get communication => _communication;
  String get comment => _comment;
  bool get hasSubmitted => _hasSubmitted;
  bool get canSubmit => !_hasSubmitted;

  // Setters
  void setStat(String stat, double value) {
    switch (stat) {
      case 'reflexes':
        _reflexes = value;
        break;
      case 'positioning':
        _positioning = value;
        break;
      case 'distribution':
        _distribution = value;
        break;
      case 'communication':
        _communication = value;
        break;
    }
    notifyListeners();
  }

  void setOverallRating(int rating) {
    final value = rating * 20.0;
    _reflexes = value;
    _positioning = value;
    _distribution = value;
    _communication = value;
    notifyListeners();
  }

  void setComment(String comment) {
    _comment = comment.trim();
    notifyListeners();
  }

  void clearError() {
    _error = null;
    notifyListeners();
  }

  /// Submits a rating for a completed booking
  Future<bool> submitRating(Booking booking) async {

    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      // Check if booking has already been rated
      final alreadyRated = await _repository.hasBookingBeenRated(booking.id);
      if (alreadyRated) {
        _error = 'Este jogo já foi avaliado';
        _isLoading = false;
        notifyListeners();
        return false;
      }

      // Create rating object
      final rating = Rating(
        id: '', // Will be generated by database
        bookingId: booking.id,
        playerId: booking.playerId,
        goalkeeperId: booking.goalkeeperId,
        rating: ((_reflexes + _positioning + _distribution + _communication) / 4).round(),
        comment: _comment.isNotEmpty ? _comment : null,
        createdAt: DateTime.now(),
        reflexes: _reflexes.round(),
        positioning: _positioning.round(),
        distribution: _distribution.round(),
        communication: _communication.round(),
      );

      // Submit to database
      await _repository.createRating(rating);

      _hasSubmitted = true;
      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _error = e.toString();
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  /// Checks if a booking can be rated (is completed and not already rated)
  Future<bool> canRateBooking(String bookingId) async {
    try {
      return !(await _repository.hasBookingBeenRated(bookingId));
    } catch (e) {
      return false;
    }
  }

  /// Gets existing rating for a booking
  Future<Rating?> getBookingRating(String bookingId) async {
    try {
      return await _repository.getBookingRating(bookingId);
    } catch (e) {
      return null;
    }
  }

  /// Resets the form for a new rating
  void reset() {
    _reflexes = 50;
    _positioning = 50;
    _distribution = 50;
    _communication = 50;
    _comment = '';
    _hasSubmitted = false;
    _error = null;
    _isLoading = false;
    notifyListeners();
  }

  /// Validates if the current user can rate this booking
  bool validateRatingPermission(Booking booking, String currentUserId) {
    // Only the player who made the booking can rate
    if (booking.playerId != currentUserId) {
      _error = 'Apenas o jogador que fez o agendamento pode avaliar';
      notifyListeners();
      return false;
    }

    // Booking must be completed
    if (!booking.isCompleted) {
      _error = 'Só pode avaliar jogos concluídos';
      notifyListeners();
      return false;
    }

    return true;
  }

  /// Gets rating statistics for display
  String getRatingDescription(int rating) {
    switch (rating) {
      case 1:
        return 'Muito Insatisfeito';
      case 2:
        return 'Insatisfeito';
      case 3:
        return 'Neutro';
      case 4:
        return 'Satisfeito';
      case 5:
        return 'Muito Satisfeito';
      default:
        return '';
    }
  }
}
