import 'package:flutter/material.dart';
import '../../data/models/rating.dart';
import '../../data/repositories/rating_repository.dart';
import '../../../booking/data/models/booking.dart';

class RatingController extends ChangeNotifier {
  final RatingRepository _repository;

  RatingController(this._repository);

  // State variables
  bool _isLoading = false;
  String? _error;
  int _selectedRating = 0;
  String _comment = '';
  bool _hasSubmitted = false;

  // Getters
  bool get isLoading => _isLoading;
  String? get error => _error;
  int get selectedRating => _selectedRating;
  String get comment => _comment;
  bool get hasSubmitted => _hasSubmitted;
  bool get canSubmit => _selectedRating > 0 && !_hasSubmitted;

  // Setters
  void setRating(int rating) {
    if (rating >= 1 && rating <= 5) {
      _selectedRating = rating;
      _error = null; // Clear any previous errors
      notifyListeners();
    }
  }

  void setComment(String comment) {
    _comment = comment.trim();
    notifyListeners();
  }

  void clearError() {
    _error = null;
    notifyListeners();
  }

  /// Submits a rating for a completed booking
  Future<bool> submitRating(Booking booking) async {
    if (_selectedRating == 0) {
      _error = 'Por favor, selecione uma classificação de 1 a 5 estrelas';
      notifyListeners();
      return false;
    }

    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      // Check if booking has already been rated
      final alreadyRated = await _repository.hasBookingBeenRated(booking.id);
      if (alreadyRated) {
        _error = 'Este jogo já foi avaliado';
        _isLoading = false;
        notifyListeners();
        return false;
      }

      // Create rating object
      final rating = Rating(
        id: '', // Will be generated by database
        bookingId: booking.id,
        playerId: booking.playerId,
        goalkeeperId: booking.goalkeeperId,
        rating: _selectedRating,
        comment: _comment.isNotEmpty ? _comment : null,
        createdAt: DateTime.now(),
      );

      // Submit to database
      await _repository.createRating(rating);

      _hasSubmitted = true;
      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _error = e.toString();
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  /// Checks if a booking can be rated (is completed and not already rated)
  Future<bool> canRateBooking(String bookingId) async {
    try {
      return !(await _repository.hasBookingBeenRated(bookingId));
    } catch (e) {
      return false;
    }
  }

  /// Gets existing rating for a booking
  Future<Rating?> getBookingRating(String bookingId) async {
    try {
      return await _repository.getBookingRating(bookingId);
    } catch (e) {
      return null;
    }
  }

  /// Resets the form for a new rating
  void reset() {
    _selectedRating = 0;
    _comment = '';
    _hasSubmitted = false;
    _error = null;
    _isLoading = false;
    notifyListeners();
  }

  /// Validates if the current user can rate this booking
  bool validateRatingPermission(Booking booking, String currentUserId) {
    // Only the player who made the booking can rate
    if (booking.playerId != currentUserId) {
      _error = 'Apenas o jogador que fez o agendamento pode avaliar';
      notifyListeners();
      return false;
    }

    // Booking must be completed
    if (!booking.isCompleted) {
      _error = 'Só pode avaliar jogos concluídos';
      notifyListeners();
      return false;
    }

    return true;
  }

  /// Gets rating statistics for display
  String getRatingDescription(int rating) {
    switch (rating) {
      case 1:
        return 'Muito Insatisfeito';
      case 2:
        return 'Insatisfeito';
      case 3:
        return 'Neutro';
      case 4:
        return 'Satisfeito';
      case 5:
        return 'Muito Satisfeito';
      default:
        return '';
    }
  }
}
