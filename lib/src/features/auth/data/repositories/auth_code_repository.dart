import 'dart:math';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/auth_code.dart';
import '../../../../core/services/secure_code_generator.dart';
import '../../../../core/services/email_logger.dart';
import '../../../../core/services/email_error_handler.dart';

/// Repository for managing authentication codes in the database
class AuthCodeRepository {
  final SupabaseClient _supabase;
  final SecureCodeGenerator _codeGenerator;

  AuthCodeRepository({
    SupabaseClient? supabase,
    SecureCodeGenerator? codeGenerator,
  }) : _supabase = supabase ?? Supabase.instance.client,
       _codeGenerator = codeGenerator ?? SecureCodeGenerator();



  /// Stores a new authentication code in the database
  /// Returns the plain text code that should be sent to the user
  /// The code is hashed before storage for security
  Future<String> storeAuthCode(
    String userId, 
    AuthCodeType type, {
    Duration? expirationDuration,
  }) async {
    EmailLogger.logAuthCodeOperation(
      operation: 'storeAuthCode',
      codeType: type.value,
      userId: userId,
    );
    
    try {
      final codePair = _codeGenerator.generateCodePair();
      final now = DateTime.now();
      final expiresAt = now.add(expirationDuration ?? const Duration(minutes: 5));

      final authCode = AuthCode(
        id: '', // Will be generated by database
        code: codePair.hashedCode, // Store the hashed version
        userId: userId,
        type: type,
        createdAt: now,
        expiresAt: expiresAt,
        isUsed: false,
      );

      EmailLogger.debug(
        'Inserting authentication code into database',
        context: {
          'userId': userId,
          'type': type.value,
          'expiresAt': expiresAt.toIso8601String(),
        },
      );

      await _supabase
          .from('auth_codes')
          .insert(authCode.toMap()..remove('id')); // Remove id to let DB generate it

      EmailLogger.logAuthCodeOperation(
        operation: 'storeAuthCode',
        codeType: type.value,
        userId: userId,
        success: true,
      );

      return codePair.plainCode; // Return the plain text code for sending
    } catch (e) {
      final exception = AuthCodeRepositoryException(
        'Failed to store authentication code: $e',
        AuthCodeRepositoryErrorType.databaseError,
        e,
      );
      
      EmailLogger.error(
        'Failed to store authentication code',
        error: e,
        context: {
          'userId': userId,
          'type': type.value,
        },
      );
      
      EmailLogger.logAuthCodeOperation(
        operation: 'storeAuthCode',
        codeType: type.value,
        userId: userId,
        success: false,
        errorMessage: EmailErrorHandler.getAuthCodeErrorMessage(exception),
      );
      
      throw exception;
    }
  }

  /// Validates an authentication code and returns the AuthCode if valid
  /// Returns null if the code is invalid, expired, or already used
  /// 
  /// [plainCode] The plain text code provided by the user
  /// [type] The type of authentication code to validate
  Future<AuthCode?> validateAuthCode(String plainCode, AuthCodeType type) async {
    EmailLogger.logAuthCodeOperation(
      operation: 'validateAuthCode',
      codeType: type.value,
    );
    
    try {
      EmailLogger.debug(
        'Querying database for unused authentication codes',
        context: {
          'type': type.value,
        },
      );
      
      // Get all unused codes of the specified type
      final response = await _supabase
          .from('auth_codes')
          .select()
          .eq('type', type.value)
          .eq('is_used', false);

      if (response.isEmpty) {
        EmailLogger.debug('No unused codes found for validation');
        EmailLogger.logAuthCodeOperation(
          operation: 'validateAuthCode',
          codeType: type.value,
          success: false,
          errorMessage: 'No unused codes found',
        );
        return null; // No unused codes found
      }

      EmailLogger.debug(
        'Found ${response.length} unused codes, checking for matches',
        context: {
          'codeCount': response.length,
        },
      );

      // Check each code to find a matching hash
      for (final data in response) {
        final authCode = AuthCode.fromMap(data);
        
        // Skip expired codes
        if (authCode.isExpired) {
          EmailLogger.debug(
            'Skipping expired code',
            context: {
              'codeId': authCode.id,
              'expiresAt': authCode.expiresAt.toIso8601String(),
            },
          );
          continue;
        }

        // Verify the plain code against the stored hash
        if (_codeGenerator.verifyCode(plainCode, authCode.code)) {
          EmailLogger.logAuthCodeOperation(
            operation: 'validateAuthCode',
            codeType: type.value,
            userId: authCode.userId,
            success: true,
          );
          
          EmailLogger.info(
            'Authentication code validated successfully',
            context: {
              'codeId': authCode.id,
              'userId': authCode.userId,
              'type': type.value,
            },
          );
          
          return authCode;
        }
      }

      EmailLogger.debug('No matching code found during validation');
      EmailLogger.logAuthCodeOperation(
        operation: 'validateAuthCode',
        codeType: type.value,
        success: false,
        errorMessage: 'Invalid code provided',
      );
      
      return null; // No matching code found
    } catch (e) {
      final exception = AuthCodeRepositoryException(
        'Failed to validate authentication code: $e',
        AuthCodeRepositoryErrorType.databaseError,
        e,
      );
      
      EmailLogger.error(
        'Database error during code validation',
        error: e,
        context: {
          'type': type.value,
        },
      );
      
      EmailLogger.logAuthCodeOperation(
        operation: 'validateAuthCode',
        codeType: type.value,
        success: false,
        errorMessage: EmailErrorHandler.getAuthCodeErrorMessage(exception),
      );
      
      throw exception;
    }
  }

  /// Marks an authentication code as used
  /// 
  /// [plainCode] The plain text code to invalidate
  Future<void> invalidateAuthCode(String plainCode) async {
    try {
      // First find the code by validating it (this will find the matching hash)
      final authCode = await _findAuthCodeByPlainText(plainCode);
      
      if (authCode != null) {
        await _supabase
            .from('auth_codes')
            .update({
              'is_used': true,
              'used_at': DateTime.now().toIso8601String(),
            })
            .eq('id', authCode.id);
      }
    } catch (e) {
      throw AuthCodeRepositoryException(
        'Failed to invalidate authentication code: $e',
        AuthCodeRepositoryErrorType.databaseError,
        e,
      );
    }
  }

  /// Helper method to find an AuthCode by its plain text value
  Future<AuthCode?> _findAuthCodeByPlainText(String plainCode) async {
    try {
      // Get all unused codes
      final response = await _supabase
          .from('auth_codes')
          .select()
          .eq('is_used', false);

      // Check each code to find a matching hash
      for (final data in response) {
        final authCode = AuthCode.fromMap(data);
        
        // Verify the plain code against the stored hash
        if (_codeGenerator.verifyCode(plainCode, authCode.code)) {
          return authCode;
        }
      }

      return null;
    } catch (e) {
      throw AuthCodeRepositoryException(
        'Failed to find authentication code: $e',
        AuthCodeRepositoryErrorType.databaseError,
        e,
      );
    }
  }

  /// Retrieves an authentication code by plain text code value
  /// 
  /// [plainCode] The plain text code to search for
  Future<AuthCode?> getAuthCode(String plainCode) async {
    return await _findAuthCodeByPlainText(plainCode);
  }

  /// Retrieves all authentication codes for a specific user and type
  Future<List<AuthCode>> getAuthCodesForUser(String userId, AuthCodeType type) async {
    try {
      final response = await _supabase
          .from('auth_codes')
          .select()
          .eq('user_id', userId)
          .eq('type', type.value)
          .order('created_at', ascending: false);

      return response.map<AuthCode>((data) => AuthCode.fromMap(data)).toList();
    } catch (e) {
      throw AuthCodeRepositoryException(
        'Failed to retrieve authentication codes for user: $e',
        AuthCodeRepositoryErrorType.databaseError,
        e,
      );
    }
  }

  /// Cleans up expired authentication codes from the database
  /// Returns the number of codes cleaned up
  Future<int> cleanupExpiredCodes() async {
    try {
      final now = DateTime.now().toIso8601String();
      
      // First, get count of expired codes
      final countResponse = await _supabase
          .from('auth_codes')
          .select('id')
          .lt('expires_at', now)
          .count();

      final count = countResponse.count;

      // Delete expired codes
      await _supabase
          .from('auth_codes')
          .delete()
          .lt('expires_at', now);

      return count;
    } catch (e) {
      throw AuthCodeRepositoryException(
        'Failed to cleanup expired authentication codes: $e',
        AuthCodeRepositoryErrorType.databaseError,
        e,
      );
    }
  }

  /// Invalidates all unused authentication codes for a specific user and type
  /// Useful when generating a new code to ensure only one valid code exists
  Future<void> invalidateUserCodes(String userId, AuthCodeType type) async {
    try {
      await _supabase
          .from('auth_codes')
          .update({
            'is_used': true,
            'used_at': DateTime.now().toIso8601String(),
          })
          .eq('user_id', userId)
          .eq('type', type.value)
          .eq('is_used', false);
    } catch (e) {
      throw AuthCodeRepositoryException(
        'Failed to invalidate user authentication codes: $e',
        AuthCodeRepositoryErrorType.databaseError,
        e,
      );
    }
  }

  /// Stores a new authentication code after invalidating existing ones for the user
  /// This ensures only one valid code exists per user per type
  Future<String> storeUniqueAuthCode(
    String userId, 
    AuthCodeType type, {
    Duration? expirationDuration,
  }) async {
    // First invalidate any existing codes for this user and type
    await invalidateUserCodes(userId, type);
    
    // Then store the new code
    return await storeAuthCode(userId, type, expirationDuration: expirationDuration);
  }
}

/// Exception thrown by AuthCodeRepository operations
class AuthCodeRepositoryException implements Exception {
  final String message;
  final AuthCodeRepositoryErrorType type;
  final dynamic originalError;

  const AuthCodeRepositoryException(
    this.message, 
    this.type, 
    [this.originalError]
  );

  @override
  String toString() => 'AuthCodeRepositoryException: $message';
}

/// Types of errors that can occur in AuthCodeRepository
enum AuthCodeRepositoryErrorType {
  databaseError,
  validationError,
  notFound,
  expired,
  alreadyUsed,
}